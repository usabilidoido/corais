<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Example: Creating a Simple Tooltip Widget With Extensions</title>
    <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Maven+Pro:400,700">
    <link rel="stylesheet" href="../../build/cssgrids/grids-min.css">
    <link rel="stylesheet" href="../assets/css/main.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <script src="../../build/yui/yui-min.js"></script>
</head>
<body>

<div id="doc">
    <h1>Example: Creating a Simple Tooltip Widget With Extensions</h1>

    

    <div class="yui3-g">
        <div class="yui3-u-3-4">
            <div id="main">
                <div class="content"><style type="text/css" scoped>
    .yui3-tooltip {
        position:absolute;
    }

    .yui3-tooltip-content {
        color: #000;
        padding: 2px 5px;
        border-color: #D4C237 #A6982B #A6982B #A6982B;
        border-width: 1px;
        border-style: solid;
        background-color: #FFEE69;
    }

    .yui3-tooltip-hidden {
        visibility:hidden;
    }

    div.yui3-hastooltip {
        border:1px solid #243356;
        background-color:#406ED9;
        color:#ffffff;
        width:25em;
        margin:20px 0px;
        padding:5px;
        cursor:default;
    }

    div.yui3-hastooltip span {
        font-style:italic;
        font-weight:bold;
        color:#ABCEFF;
    }

    .yui3-tooltip-content strong {
        font-weight:bold;
    }
</style>

<div class="intro">
    <p>This is an advanced example, in which we create a Tooltip widget, by extending the base <code>Widget</code> class, and adding <code>WidgetStack</code> and <code>WidgetPosition</code> extensions, through <code>Base.build</code>.</p>
</div>

<div class="example">
    <div id="delegate">
    <div class="yui3-hastooltip" title="Tooltip 1" id="tt1">Tooltip One <span>(content from title)</span></div>
    <div class="yui3-hastooltip" title="Tooltip 2" id="tt2">Tooltip Two <span>(content set in event listener)</span></div>
    <div class="yui3-hastooltip" title="Tooltip 3" id="tt3">Tooltip Three <span>(content from lookup)</span></div>
    <div class="yui3-hastooltip" title="Tooltip 4" id="tt4">Tooltip Four <span>(content from title)</span></div>
    <label><input type="checkbox" id="prevent" /> Prevent Tooltip Four</label>
</div>

<script type="text/javascript">
YUI().use("event-mouseenter", "widget", "widget-position", "widget-stack", function(Y) {
    var Lang = Y.Lang,
        Node = Y.Node,
        OX = -10000,
        OY = -10000;

    var Tooltip = Y.Base.create("tooltip", Y.Widget, [Y.WidgetPosition, Y.WidgetStack], {

        // PROTOTYPE METHODS/PROPERTIES

        /*
         * Initialization Code: Sets up privately used state
         * properties, and publishes the events Tooltip introduces
         */
        initializer : function(config) {

            this._triggerClassName = this.getClassName("trigger");

            // Currently bound trigger node information
            this._currTrigger = {
                node: null,
                title: null,
                mouseX: Tooltip.OFFSCREEN_X,
                mouseY: Tooltip.OFFSCREEN_Y
            };

            // Event handles - mouse over is set on the delegate
            // element, mousemove and mouseleave are set on the trigger node
            this._eventHandles = {
                delegate: null,
                trigger: {
                    mouseMove : null,
                    mouseOut: null
                }
            };

            // Show/hide timers
            this._timers = {
                show: null,
                hide: null
            };

            // Publish events introduced by Tooltip. Note the triggerEnter event is preventable,
            // with the default behavior defined in the _defTriggerEnterFn method 
            this.publish("triggerEnter", {defaultFn: this._defTriggerEnterFn, preventable:true});
            this.publish("triggerLeave", {preventable:false});
        },

        /*
         * Destruction Code: Clears event handles, timers,
         * and current trigger information
         */
        destructor : function() {
            this._clearCurrentTrigger();
            this._clearTimers();
            this._clearHandles();
        },

        /*
         * bindUI is used to bind attribute change and dom event
         * listeners
         */
        bindUI : function() {
            this.after("delegateChange", this._afterSetDelegate);
            this.after("nodesChange", this._afterSetNodes);

            this._bindDelegate();
        },

        /*
         * syncUI is used to update the rendered DOM, based on the current
         * Tooltip state
         */
        syncUI : function() {
            this._uiSetNodes(this.get("triggerNodes"));
        },

        /*
         * Public method, which can be used by triggerEvent event listeners
         * to set the content of the tooltip for the current trigger node
         */
        setTriggerContent : function(content) {
            var contentBox = this.get("contentBox");
            contentBox.set("innerHTML", "");

            if (content) {
                if (content instanceof Node) {
                    for (var i = 0, l = content.size(); i < l; ++i) {
                        contentBox.appendChild(content.item(i));
                    }
                } else if (Lang.isString(content)) {
                    contentBox.set("innerHTML", content);
                }
            }
        },

        /*
         * Default attribute change listener for 
         * the triggerNodes attribute
         */
        _afterSetNodes : function(e) {
            this._uiSetNodes(e.newVal);
        },

        /*
         * Default attribute change listener for 
         * the delegate attribute
         */
        _afterSetDelegate : function(e) {
            this._bindDelegate(e.newVal);
        },

        /*
         * Updates the rendered DOM to reflect the
         * set of trigger nodes passed in
         */
        _uiSetNodes : function(nodes) {
            if (this._triggerNodes) {
                this._triggerNodes.removeClass(this._triggerClassName);
            }

            if (nodes) {
                this._triggerNodes = nodes;
                this._triggerNodes.addClass(this._triggerClassName);
            }
        },

        /*
         * Attaches the default mouseover DOM listener to the 
         * current delegate node
         */
        _bindDelegate : function() {
            var eventHandles = this._eventHandles;

            if (eventHandles.delegate) {
                eventHandles.delegate.detach();
                eventHandles.delegate = null;
            }
            eventHandles.delegate = Y.delegate("mouseenter", Y.bind(this._onNodeMouseEnter, this), this.get("delegate"), "." + this._triggerClassName);
        },

        /*
         * Default mouse enter DOM event listener.
         * 
         * Delegates to the _enterTrigger method,
         * if the mouseover enters a trigger node.
         */
        _onNodeMouseEnter : function(e) {
            var node = e.currentTarget;
            if (node && (!this._currTrigger.node || !node.compareTo(this._currTrigger.node))) {
                this._enterTrigger(node, e.pageX, e.pageY);
            }
        },

        /*
         * Default mouse leave DOM event listener
         * 
         * Delegates to _leaveTrigger if the mouse
         * leaves the current trigger node
         */
        _onNodeMouseLeave : function(e) {
            this._leaveTrigger(e.currentTarget);
        },

        /*
         * Default mouse move DOM event listener
         */
        _onNodeMouseMove : function(e) {
            this._overTrigger(e.pageX, e.pageY);
        },

        /*
         * Default handler invoked when the mouse enters
         * a trigger node. Fires the triggerEnter
         * event which can be prevented by listeners to 
         * show the tooltip from being displayed.
         */
        _enterTrigger : function(node, x, y) {
            this._setCurrentTrigger(node, x, y);
            this.fire("triggerEnter", {node:node, pageX:x, pageY:y});
        },

        /*
         * Default handler for the triggerEvent event,
         * which will setup the timer to display the tooltip,
         * if the default handler has not been prevented.
         */
        _defTriggerEnterFn : function(e) {
            var node = e.node;
            if (!this.get("disabled")) {
                this._clearTimers();
                var delay = (this.get("visible")) ? 0 : this.get("showDelay");
                this._timers.show = Y.later(delay, this, this._showTooltip, [node]);
            }
        },

        /*
         * Default handler invoked when the mouse leaves
         * the current trigger node. Fires the triggerLeave
         * event and sets up the hide timer
         */
        _leaveTrigger : function(node) {
            this.fire("triggerLeave");

            this._clearCurrentTrigger();
            this._clearTimers();

            this._timers.hide = Y.later(this.get("hideDelay"), this, this._hideTooltip);
        },

        /*
         * Default handler invoked for mousemove events
         * on the trigger node. Stores the current mouse 
         * x, y positions
         */
        _overTrigger : function(x, y) {
            this._currTrigger.mouseX = x;
            this._currTrigger.mouseY = y;
        },

        /*
         * Shows the tooltip, after moving it to the current mouse
         * position.
         */
        _showTooltip : function(node) {
            var x = this._currTrigger.mouseX;
            var y = this._currTrigger.mouseY;

            this.move(x + Tooltip.OFFSET_X, y + Tooltip.OFFSET_Y);

            this.show();
            this._clearTimers();

            this._timers.hide = Y.later(this.get("autoHideDelay"), this, this._hideTooltip);
        },

        /*
         * Hides the tooltip, after clearing existing timers.
         */
        _hideTooltip : function() {
            this._clearTimers();
            this.hide();
        },

        /*
         * Set the rendered content of the tooltip for the current
         * trigger, based on (in order of precedence):
         * 
         * a). The string/node content attribute value
         * b). From the content lookup map if it is set, or 
         * c). From the title attribute if set.
         */
        _setTriggerContent : function(node) {
            var content = this.get("content");
            if (content && !(content instanceof Node || Lang.isString(content))) {
                content = content[node.get("id")] || node.getAttribute("title");
            }
            this.setTriggerContent(content);
        },

        /*
         * Set the currently bound trigger node information, clearing 
         * out the title attribute if set and setting up mousemove/out 
         * listeners.
         */
        _setCurrentTrigger : function(node, x, y) {

            var currTrigger = this._currTrigger,
                triggerHandles = this._eventHandles.trigger;

            this._setTriggerContent(node);

            triggerHandles.mouseMove = Y.on("mousemove", Y.bind(this._onNodeMouseMove, this), node);
            triggerHandles.mouseOut = Y.on("mouseleave", Y.bind(this._onNodeMouseLeave, this), node);

            var title = node.getAttribute("title");
            node.setAttribute("title", "");

            currTrigger.mouseX = x;
            currTrigger.mouseY = y;
            currTrigger.node = node;
            currTrigger.title = title;
        },

        /*
         * Clear out the current trigger state, restoring
         * the title attribute on the trigger node, 
         * if it was originally set.
         */
        _clearCurrentTrigger : function() {

            var currTrigger = this._currTrigger,
                triggerHandles = this._eventHandles.trigger;

            if (currTrigger.node) {
                var node = currTrigger.node;
                var title = currTrigger.title || "";

                currTrigger.node = null;
                currTrigger.title = "";

                triggerHandles.mouseMove.detach();
                triggerHandles.mouseOut.detach();
                triggerHandles.mouseMove = null;
                triggerHandles.mouseOut = null;

                node.setAttribute("title", title);
            }
        },

        /*
         * Cancel any existing show/hide timers
         */
        _clearTimers : function() {
            var timers = this._timers;
            if (timers.hide) {
                timers.hide.cancel();
                timers.hide = null;
            }
            if (timers.show) {
              timers.show.cancel();
              timers.show = null;
            }
        },

        /*
         * Detach any stored event handles
         */
        _clearHandles : function() {
            var eventHandles = this._eventHandles;

            if (eventHandles.delegate) {
                this._eventHandles.delegate.detach();
            }
            if (eventHandles.trigger.mouseOut) {
                eventHandles.trigger.mouseOut.detach();
            }
            if (eventHandles.trigger.mouseMove) {
                eventHandles.trigger.mouseMove.detach();
            }
        }
    }, {
    
        // STATIC METHODS/PROPERTIES
       
        OFFSET_X : 15,
        OFFSET_Y : 15,
        OFFSCREEN_X : OX,
        OFFSCREEN_Y : OY,

        ATTRS : {
    
            /* 
             * The tooltip content. This can either be a fixed content value, 
             * or a map of id-to-values, designed to be used when a single
             * tooltip is mapped to multiple trigger elements.
             */
            content : {
                value: null
            },
    
            /* 
             * The set of nodes to bind to the tooltip instance. Can be a string, 
             * or a node instance.
             */
            triggerNodes : {
                value: null,
                setter: function(val) {
                    if (val && Lang.isString(val)) {
                        val = Node.all(val);
                    }
                    return val;
                }
            },
    
            /*
             * The delegate node to which event listeners should be attached.
             * This node should be an ancestor of all trigger nodes bound
             * to the instance. By default the document is used.
             */
            delegate : {
                value: null,
                setter: function(val) {
                    return Y.one(val) || Y.one("document");
                }
            },
    
            /*
             * The time to wait, after the mouse enters the trigger node,
             * to display the tooltip
             */
            showDelay : {
                value:250
            },
    
            /*
             * The time to wait, after the mouse leaves the trigger node,
             * to hide the tooltip
             */
            hideDelay : {
                value:10
            },
    
            /*
             * The time to wait, after the tooltip is first displayed for 
             * a trigger node, to hide it, if the mouse has not left the 
             * trigger node
             */
            autoHideDelay : {
                value:2000
            },
    
            /*
             * Override the default visibility set by the widget base class
             */
            visible : {
                value:false
            },
    
            /*
             * Override the default XY value set by the widget base class,
             * to position the tooltip offscreen
             */
            xy: {
                value:[OX, OY]
            }
        }
    });

    var tt = new Tooltip({
        triggerNodes:".yui3-hastooltip",
        delegate: "#delegate",
        content: {
            tt3: "Tooltip 3 (from lookup)"
        },
        shim:false,
        zIndex:2
    });
    tt.render();

    tt.on("triggerEnter", function(e) {
        var node = e.node;
        if (node && node.get("id") == "tt2") {
            this.setTriggerContent("Tooltip 2 (from triggerEvent)");
        }
    });

    var prevent = Y.one("#prevent");
    tt.on("triggerEnter", function(e) {
        var node = e.node;
        if (prevent.get("checked")) {
            if (node && node.get("id") == "tt4") {
                e.preventDefault();
            }
        }
    });
});
</script>

</div>

<h2>Creating A Tooltip Widget Class</h2>

<h3>Basic Class Structure</h3>

<p>As with the basic <a href="widget-extend.html">"Extending Widget"</a> example, the <code>Tooltip</code> class will extend the <code>Widget</code> base class and follows the same pattern we use for other classes which extend Base.</p>

<p>Namely:</p>

<ul>
    <li>Set up the constructor to invoke the superclass constructor</li>
    <li>Define a <code>NAME</code> property, to identify the class</li>
    <li>Define the default attribute configuration, using the <code>ATTRS</code> property</li>
    <li>Implement prototype methods</li>
</ul>

<p>This basic structure is shown below:</p>

<pre class="code prettyprint">&#x2F;* 
 *  Required NAME static field, used to identify the Widget class and 
 *  used as an event prefix, to generate class names etc. (set to the 
 *  class name in camel case). 
 *&#x2F;
Tooltip.NAME = &quot;tooltip&quot;;

&#x2F;* Default Tooltip Attributes *&#x2F;
Tooltip.ATTRS = {

    &#x2F;* 
     * The tooltip content. This can either be a fixed content value, 
     * or a map of id-to-values, designed to be used when a single
     * tooltip is mapped to multiple trigger elements.
     *&#x2F;
    content : {
        value: null
    },

    &#x2F;* 
     * The set of nodes to bind to the tooltip instance. Can be a string, 
     * or a node instance.
     *&#x2F;
    triggerNodes : {
        value: null,
        setter: function(val) {
            if (val &amp;&amp; Lang.isString(val)) {
                val = Node.all(val);
            }
            return val;
        }
    },

    &#x2F;*
     * The delegate node to which event listeners should be attached.
     * This node should be an ancestor of all trigger nodes bound
     * to the instance. By default the document is used.
     *&#x2F;
    delegate : {
        value: null,
        setter: function(val) {
            return Y.one(val) || Y.one(&quot;document&quot;);
        }
    },

    &#x2F;*
     * The time to wait, after the mouse enters the trigger node,
     * to display the tooltip
     *&#x2F;
    showDelay : {
        value:250
    },

    &#x2F;*
     * The time to wait, after the mouse leaves the trigger node,
     * to hide the tooltip
     *&#x2F;
    hideDelay : {
        value:10
    },

    &#x2F;*
     * The time to wait, after the tooltip is first displayed for 
     * a trigger node, to hide it, if the mouse has not left the 
     * trigger node
     *&#x2F;
    autoHideDelay : {
        value:2000
    },

    &#x2F;*
     * Override the default visibility set by the widget base class
     *&#x2F;
    visible : {
        value:false
    },

    &#x2F;*
     * Override the default XY value set by the widget base class,
     * to position the tooltip offscreen
     *&#x2F;
    xy: {
        value:[Tooltip.OFFSCREEN_X, Tooltip.OFFSCREEN_Y]
    }
};

Y.extend(Tooltip, Y.Widget, { 
    &#x2F;&#x2F; Prototype methods&#x2F;properties
});</pre>


<h3>Adding WidgetPosition and WidgetStack Extension Support</h3>

<p>The Tooltip class also needs basic positioning and stacking (z-index, shimming) support. As with the <a href="widget-build.html">Custom Widget Classes</a> example, we use
<code>Base.create</code> to create a new <code>Tooltip</code> class with this support:</p>

<pre class="code prettyprint">var Tooltip = Y.Base.create(&quot;tooltip&quot;, Y.Widget, [Y.WidgetPosition, Y.WidgetStack], 
                                  { ... prototype properties ... },
                                  { ... static properties ... },</pre>


<h3>Lifecycle Methods: initializer, destructor</h3>

<p>The <code>initializer</code> method is invoked during the <code>init</code> lifecycle phase, after the attributes are configured for each class. <code>Tooltip</code> uses it 
to setup the private state variables it will use to store the trigger node currently being serviced by the tooltip instance, event handles and show/hide timers.</p>

<pre class="code prettyprint">initializer : function(config) {

    this._triggerClassName = this.getClassName(&quot;trigger&quot;);

    &#x2F;&#x2F; Currently bound trigger node information
    this._currTrigger = {
        node: null,
        title: null,
        mouseX: Tooltip.OFFSCREEN_X,
        mouseY: Tooltip.OFFSCREEN_Y
    };

    &#x2F;&#x2F; Event handles - mouse over is set on the delegate
    &#x2F;&#x2F; element, mousemove and mouseleave are set on the trigger node
    this._eventHandles = {
        delegate: null,
        trigger: {
            mouseMove : null,
            mouseOut: null
        }
    };

    &#x2F;&#x2F; Show&#x2F;hide timers
    this._timers = {
        show: null,
        hide: null
    };

    &#x2F;&#x2F; Publish events introduced by Tooltip. Note the triggerEnter event is preventable,
    &#x2F;&#x2F; with the default behavior defined in the _defTriggerEnterFn method 
    this.publish(&quot;triggerEnter&quot;, {defaultFn: this._defTriggerEnterFn, preventable:true});
    this.publish(&quot;triggerLeave&quot;, {preventable:false});
}</pre>


<p>The <code>destructor</code> is used to clear out stored state, detach any event handles and clear out the show/hide timers:</p>

<pre class="code prettyprint">destructor : function() {
    this._clearCurrentTrigger();
    this._clearTimers();
    this._clearHandles();
}</pre>


<h3>Lifecycle Methods: bindUI, syncUI</h3>

<p>The <code>bindUI</code> and <code>syncUI</code> are invoked by the base Widget class' <code>renderer</code> method.</p>

<p><code>bindUI</code> is used to bind the attribute change listeners used to update the rendered UI from the current state of the widget and also to bind
the DOM listeners required to enable the UI for interaction.</p>

<p><code>syncUI</code> is used to sync the UI state from the current widget state, when initially rendered.</p>

<p><em>NOTE:</em> Widget's <code>renderer</code> method also invokes the <code>renderUI</code> method, which is responsible for laying down any additional content elements a widget requires. However
tooltip does not have any additional elements in needs to add to the DOM, outside of the default Widget boundingBox and contentBox.</p>

<pre class="code prettyprint">bindUI : function() {
    this.after(&quot;delegateChange&quot;, this._afterSetDelegate);
    this.after(&quot;nodesChange&quot;, this._afterSetNodes);

    this._bindDelegate();
},

syncUI : function() {
    this._uiSetNodes(this.get(&quot;triggerNodes&quot;));
}</pre>


<h3>Attribute Supporting Methods</h3>

<p>Tooltip's <code>triggerNodes</code>, which defines the set of nodes which should trigger this tooltip instance,
has a couple of supporting methods associated with it.</p>

<p>The <code>_afterSetNodes</code> method is the default attribute change event handler for the <code>triggerNodes</code>
attribute. It invokes the <code>_uiSetNodes</code> method, which marks all trigger nodes with a trigger class name (<code>yui-tooltip-trigger</code>) when set.</p>

<pre class="code prettyprint">_afterSetNodes : function(e) {
    this._uiSetNodes(e.newVal);
},

_uiSetNodes : function(nodes) {
    if (this._triggerNodes) {
        this._triggerNodes.removeClass(this._triggerClassName);
    }

    if (nodes) {
        this._triggerNodes = nodes;
        this._triggerNodes.addClass(this._triggerClassName);
    }
},</pre>


<p>Similarly the <code>_afterSetDelegate</code> method is the default attribute change listener for the <code>delegate</code> attribute,
and invokes <code>_bindDelegate</code> to set up the listeners when a new delegate node is set. We use <code>Y.delegate</code> support, along with Event's <code>mouseenter</code> support, 
which means the only thing we need to do is tell delegate which node we want to act as the delegate, and which elements we want to target using the <code>&quot;.&quot; + this._triggerClassName</code> selector.</p>

<pre class="code prettyprint">_afterSetDelegate : function(e) {
    this._bindDelegate(e.newVal);
},

_bindDelegate : function() {
    var eventHandles = this._eventHandles;

    if (eventHandles.delegate) {
        eventHandles.delegate.detach();
        eventHandles.delegate = null;
    }
    eventHandles.delegate = Y.delegate(&quot;mouseenter&quot;, Y.bind(this._onNodeMouseEnter, this), this.get(&quot;delegate&quot;), &quot;.&quot; + this._triggerClassName);
},</pre>


<h3>DOM Event Handlers</h3>

<p>Tooltips interaction revolves around the <code>mouseenter</code>, <code>mousemove</code> and <code>mouseleave</code> DOM events. The mousenter listener is the only listener set up initially, on the <code>delegate</code> node:</p>

<pre class="code prettyprint">_onNodeMouseEnter : function(e) {
    var node = e.currentTarget;
    if (node &amp;&amp; (!this._currTrigger.node || !node.compareTo(this._currTrigger.node))) {
        this._enterTrigger(node, e.pageX, e.pageY);
    }
}</pre>


<p>Since the <code>mouseenter</code> implementation doesn't invoke it's listeners for <code>mouseover</code> events generated from elements nested 
inside the targeted node (for example when mousing out of a child element of a trigger node), there are no additional checks we need to perform other than to see if the node is the current trigger, before handing off to 
the <code>_enterTrigger</code> method to setup the current trigger state and attach mousemove and mouseleave listeners on the current trigger node.</p>

<p>The mouseleave listener delegates to the <code>_leaveTrigger</code> method, and again, since the <code>mouseleave</code> implementation deals with nested elements, we don't need to perform any additional target checks:</p>

<pre class="code prettyprint">_onNodeMouseLeave : function(e) {
    this._leaveTrigger(e.currentTarget);
}</pre>


<p>The mouse move listener delegates to the <code>_overTrigger</code> method to store the current mouse XY co-ordinates (used to position the Tooltip when it is displayed after the <code>showDelay</code>):</p>

<pre class="code prettyprint">_onNodeMouseMove : function(e) {
    this._overTrigger(e.pageX, e.pageY);
}</pre>


<h3>Trigger Event Delegates: _enterTrigger, _leaveTrigger, _overTrigger</h3>

<p>As seen above, the DOM event handlers delegate to the <code>_enterTrigger, _leaveTrigger and _overTrigger</code> methods to update the 
Tooltip state based on the currently active trigger node.</p>

<p>The <code>_enterTrigger</code> method sets the current trigger state (which node is the current tooltip trigger, 
what the current mouse XY position is, etc.). The method also fires the <code>triggerEnter</code> event, whose default function actually handles 
showing the tooltip after the configured <code>showDelay</code> period. The <code>triggerEnter</code> event can be prevented by listeners, allowing 
users to prevent the tooltip from being shown if required. (<code>triggerEnter</code> listeners are passed the current trigger node and pageX, pageY mouse co-ordinates as event facade properties):</p>

<pre class="code prettyprint">_enterTrigger : function(node, x, y) {
    this._setCurrentTrigger(node, x, y);
    this.fire(&quot;triggerEnter&quot;, null, node, x, y);
},

_defTriggerEnterFn : function(e) {
    var node = e.node;
    if (!this.get(&quot;disabled&quot;)) {
        this._clearTimers();
        var delay = (this.get(&quot;visible&quot;)) ? 0 : this.get(&quot;showDelay&quot;);
        this._timers.show = Y.later(delay, this, this._showTooltip, [node]);
    }
},</pre>


<p>Similarly the <code>_leaveTrigger</code> method is invoked when the mouse leaves a trigger node, and clears any stored state, timers and listeners before setting up
the <code>hideDelay</code> timer. It fires a <code>triggerLeave</code> event, but cannot be prevented, and has no default behavior to prevent:</p>

<pre class="code prettyprint">_leaveTrigger : function(node) {
    this.fire(&quot;triggerLeave&quot;);

    this._clearCurrentTrigger();
    this._clearTimers();

    this._timers.hide = Y.later(this.get(&quot;hideDelay&quot;), this, this._hideTooltip);
},</pre>


<p>As mentioned previously, the <code>_overTrigger</code> method simply stores the current mouse XY co-ordinates for use when the tooltip is shown:</p>

<pre class="code prettyprint">_overTrigger : function(x, y) {
    this._currTrigger.mouseX = x;
    this._currTrigger.mouseY = y;
}</pre>


<h3>Setting Tooltip Content</h3>

<p>Since the content for a tooltip is usually a function of the trigger node and not constant, <code>Tooltip</code> provides a number of ways to set the content.</p>

<ol>
    <li>Setting the <code>content</code> attribute to a string or node. In this case, the value of the <code>content</code> attribute is used
    for all triggerNodes</li>
    <li>Setting the <code>content</code> attribute to an object literal, containing a map of triggerNode id to content. The content for a trigger node
    will be set using the map, when the tooltip is triggered for the node.</li>
    <li>Setting the title attribute on the trigger node. The value of the title attribute is used to set the tooltip content,
    when triggered for the node.</li>
    <li>By calling the <code>setTriggerContent</code> method to set content for a specific trigger node, in a <code>triggerEnter</code> event listener.</li>
</ol>

<p>The precedence of these methods is handled in the <code>_setTriggerContent</code> method, invoked when the mouse enters a trigger:</p>

<pre class="code prettyprint">_setTriggerContent : function(node) {
    var content = this.get(&quot;content&quot;);
    if (content &amp;&amp; !(content instanceof Node || Lang.isString(content))) {
        content = content[node.get(&quot;id&quot;)] || node.getAttribute(&quot;title&quot;);
    }
    this.setTriggerContent(content);
},

setTriggerContent : function(content) {
    var contentBox = this.get(&quot;contentBox&quot;);
    contentBox.set(&quot;innerHTML&quot;, &quot;&quot;);

    if (content) {
        if (content instanceof Node) {
            for (var i = 0, l = content.size(); i &lt; l; ++i) {
                contentBox.appendChild(content.item(i));
            }
        } else if (Lang.isString(content)) {
            contentBox.set(&quot;innerHTML&quot;, content);
        }
    }
}</pre>


<p>Calling the public <code>setTriggerContent</code> in a <code>triggerEvent</code> listener will over-ride content set using the <code>content</code> attribute or the trigger node's title value.</p>

<h3>Using Tooltip</h3>

<p>For this example, we set up 4 DIV elements which will act as tooltip triggers. They are all marked using a <code>yui-hastooltip</code> class, so that they can be queried using a simple selector, passed as the value for the <code>triggerNodes</code> attribute in the tooltip's constructor Also all 4 trigger nodes are contained in a wrapper DIV with <code>id=&quot;delegate&quot;</code> which will act as the <code>delegate</code> node.</p>

<pre class="code prettyprint">var tt = new Tooltip({
    triggerNodes:&quot;.yui3-hastooltip&quot;,
    delegate: &quot;#delegate&quot;,
    content: {
        tt3: &quot;Tooltip 3 (from lookup)&quot;
    },
    shim:false,
    zIndex:2
});
tt.render();</pre>


<p>The tooltip content for each of the trigger nodes is setup differently. The first trigger node uses the title attribute to set it's content. The third trigger node's content is set using the content map set in the constructor above. The second trigger node's content is set using a <code>triggerEnter</code> event listener and the <code>setTriggerContent</code> method as shown below:</p>

<pre class="code prettyprint">tt.on(&quot;triggerEnter&quot;, function(e) {
    var node = e.node;
    if (node &amp;&amp; node.get(&quot;id&quot;) == &quot;tt2&quot;) {
        this.setTriggerContent(&quot;Tooltip 2 (from triggerEvent)&quot;);
    }
});</pre>


<p>The fourth trigger node's content is set using it's title attribute, however it also has a <code>triggerEvent</code> listener which prevents the tooltip from being displayed for it, if the checkbox is checked.</p>

<pre class="code prettyprint">var prevent = Y.one(&quot;#prevent&quot;);
tt.on(&quot;triggerEnter&quot;, function(e) {
    var node = e.node;
    if (prevent.get(&quot;checked&quot;)) {
        if (node &amp;&amp; node.get(&quot;id&quot;) == &quot;tt4&quot;) {
            e.preventDefault();
        }
    }
});</pre>


<h2>Complete Example Source</h2>
<pre class="code prettyprint">&lt;div id=&quot;delegate&quot;&gt;
    &lt;div class=&quot;yui3-hastooltip&quot; title=&quot;Tooltip 1&quot; id=&quot;tt1&quot;&gt;Tooltip One &lt;span&gt;(content from title)&lt;&#x2F;span&gt;&lt;&#x2F;div&gt;
    &lt;div class=&quot;yui3-hastooltip&quot; title=&quot;Tooltip 2&quot; id=&quot;tt2&quot;&gt;Tooltip Two &lt;span&gt;(content set in event listener)&lt;&#x2F;span&gt;&lt;&#x2F;div&gt;
    &lt;div class=&quot;yui3-hastooltip&quot; title=&quot;Tooltip 3&quot; id=&quot;tt3&quot;&gt;Tooltip Three &lt;span&gt;(content from lookup)&lt;&#x2F;span&gt;&lt;&#x2F;div&gt;
    &lt;div class=&quot;yui3-hastooltip&quot; title=&quot;Tooltip 4&quot; id=&quot;tt4&quot;&gt;Tooltip Four &lt;span&gt;(content from title)&lt;&#x2F;span&gt;&lt;&#x2F;div&gt;
    &lt;label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;prevent&quot; &#x2F;&gt; Prevent Tooltip Four&lt;&#x2F;label&gt;
&lt;&#x2F;div&gt;

&lt;script type=&quot;text&#x2F;javascript&quot;&gt;
YUI().use(&quot;event-mouseenter&quot;, &quot;widget&quot;, &quot;widget-position&quot;, &quot;widget-stack&quot;, function(Y) {
    var Lang = Y.Lang,
        Node = Y.Node,
        OX = -10000,
        OY = -10000;

    var Tooltip = Y.Base.create(&quot;tooltip&quot;, Y.Widget, [Y.WidgetPosition, Y.WidgetStack], {

        &#x2F;&#x2F; PROTOTYPE METHODS&#x2F;PROPERTIES

        &#x2F;*
         * Initialization Code: Sets up privately used state
         * properties, and publishes the events Tooltip introduces
         *&#x2F;
        initializer : function(config) {

            this._triggerClassName = this.getClassName(&quot;trigger&quot;);

            &#x2F;&#x2F; Currently bound trigger node information
            this._currTrigger = {
                node: null,
                title: null,
                mouseX: Tooltip.OFFSCREEN_X,
                mouseY: Tooltip.OFFSCREEN_Y
            };

            &#x2F;&#x2F; Event handles - mouse over is set on the delegate
            &#x2F;&#x2F; element, mousemove and mouseleave are set on the trigger node
            this._eventHandles = {
                delegate: null,
                trigger: {
                    mouseMove : null,
                    mouseOut: null
                }
            };

            &#x2F;&#x2F; Show&#x2F;hide timers
            this._timers = {
                show: null,
                hide: null
            };

            &#x2F;&#x2F; Publish events introduced by Tooltip. Note the triggerEnter event is preventable,
            &#x2F;&#x2F; with the default behavior defined in the _defTriggerEnterFn method 
            this.publish(&quot;triggerEnter&quot;, {defaultFn: this._defTriggerEnterFn, preventable:true});
            this.publish(&quot;triggerLeave&quot;, {preventable:false});
        },

        &#x2F;*
         * Destruction Code: Clears event handles, timers,
         * and current trigger information
         *&#x2F;
        destructor : function() {
            this._clearCurrentTrigger();
            this._clearTimers();
            this._clearHandles();
        },

        &#x2F;*
         * bindUI is used to bind attribute change and dom event
         * listeners
         *&#x2F;
        bindUI : function() {
            this.after(&quot;delegateChange&quot;, this._afterSetDelegate);
            this.after(&quot;nodesChange&quot;, this._afterSetNodes);

            this._bindDelegate();
        },

        &#x2F;*
         * syncUI is used to update the rendered DOM, based on the current
         * Tooltip state
         *&#x2F;
        syncUI : function() {
            this._uiSetNodes(this.get(&quot;triggerNodes&quot;));
        },

        &#x2F;*
         * Public method, which can be used by triggerEvent event listeners
         * to set the content of the tooltip for the current trigger node
         *&#x2F;
        setTriggerContent : function(content) {
            var contentBox = this.get(&quot;contentBox&quot;);
            contentBox.set(&quot;innerHTML&quot;, &quot;&quot;);

            if (content) {
                if (content instanceof Node) {
                    for (var i = 0, l = content.size(); i &lt; l; ++i) {
                        contentBox.appendChild(content.item(i));
                    }
                } else if (Lang.isString(content)) {
                    contentBox.set(&quot;innerHTML&quot;, content);
                }
            }
        },

        &#x2F;*
         * Default attribute change listener for 
         * the triggerNodes attribute
         *&#x2F;
        _afterSetNodes : function(e) {
            this._uiSetNodes(e.newVal);
        },

        &#x2F;*
         * Default attribute change listener for 
         * the delegate attribute
         *&#x2F;
        _afterSetDelegate : function(e) {
            this._bindDelegate(e.newVal);
        },

        &#x2F;*
         * Updates the rendered DOM to reflect the
         * set of trigger nodes passed in
         *&#x2F;
        _uiSetNodes : function(nodes) {
            if (this._triggerNodes) {
                this._triggerNodes.removeClass(this._triggerClassName);
            }

            if (nodes) {
                this._triggerNodes = nodes;
                this._triggerNodes.addClass(this._triggerClassName);
            }
        },

        &#x2F;*
         * Attaches the default mouseover DOM listener to the 
         * current delegate node
         *&#x2F;
        _bindDelegate : function() {
            var eventHandles = this._eventHandles;

            if (eventHandles.delegate) {
                eventHandles.delegate.detach();
                eventHandles.delegate = null;
            }
            eventHandles.delegate = Y.delegate(&quot;mouseenter&quot;, Y.bind(this._onNodeMouseEnter, this), this.get(&quot;delegate&quot;), &quot;.&quot; + this._triggerClassName);
        },

        &#x2F;*
         * Default mouse enter DOM event listener.
         * 
         * Delegates to the _enterTrigger method,
         * if the mouseover enters a trigger node.
         *&#x2F;
        _onNodeMouseEnter : function(e) {
            var node = e.currentTarget;
            if (node &amp;&amp; (!this._currTrigger.node || !node.compareTo(this._currTrigger.node))) {
                this._enterTrigger(node, e.pageX, e.pageY);
            }
        },

        &#x2F;*
         * Default mouse leave DOM event listener
         * 
         * Delegates to _leaveTrigger if the mouse
         * leaves the current trigger node
         *&#x2F;
        _onNodeMouseLeave : function(e) {
            this._leaveTrigger(e.currentTarget);
        },

        &#x2F;*
         * Default mouse move DOM event listener
         *&#x2F;
        _onNodeMouseMove : function(e) {
            this._overTrigger(e.pageX, e.pageY);
        },

        &#x2F;*
         * Default handler invoked when the mouse enters
         * a trigger node. Fires the triggerEnter
         * event which can be prevented by listeners to 
         * show the tooltip from being displayed.
         *&#x2F;
        _enterTrigger : function(node, x, y) {
            this._setCurrentTrigger(node, x, y);
            this.fire(&quot;triggerEnter&quot;, {node:node, pageX:x, pageY:y});
        },

        &#x2F;*
         * Default handler for the triggerEvent event,
         * which will setup the timer to display the tooltip,
         * if the default handler has not been prevented.
         *&#x2F;
        _defTriggerEnterFn : function(e) {
            var node = e.node;
            if (!this.get(&quot;disabled&quot;)) {
                this._clearTimers();
                var delay = (this.get(&quot;visible&quot;)) ? 0 : this.get(&quot;showDelay&quot;);
                this._timers.show = Y.later(delay, this, this._showTooltip, [node]);
            }
        },

        &#x2F;*
         * Default handler invoked when the mouse leaves
         * the current trigger node. Fires the triggerLeave
         * event and sets up the hide timer
         *&#x2F;
        _leaveTrigger : function(node) {
            this.fire(&quot;triggerLeave&quot;);

            this._clearCurrentTrigger();
            this._clearTimers();

            this._timers.hide = Y.later(this.get(&quot;hideDelay&quot;), this, this._hideTooltip);
        },

        &#x2F;*
         * Default handler invoked for mousemove events
         * on the trigger node. Stores the current mouse 
         * x, y positions
         *&#x2F;
        _overTrigger : function(x, y) {
            this._currTrigger.mouseX = x;
            this._currTrigger.mouseY = y;
        },

        &#x2F;*
         * Shows the tooltip, after moving it to the current mouse
         * position.
         *&#x2F;
        _showTooltip : function(node) {
            var x = this._currTrigger.mouseX;
            var y = this._currTrigger.mouseY;

            this.move(x + Tooltip.OFFSET_X, y + Tooltip.OFFSET_Y);

            this.show();
            this._clearTimers();

            this._timers.hide = Y.later(this.get(&quot;autoHideDelay&quot;), this, this._hideTooltip);
        },

        &#x2F;*
         * Hides the tooltip, after clearing existing timers.
         *&#x2F;
        _hideTooltip : function() {
            this._clearTimers();
            this.hide();
        },

        &#x2F;*
         * Set the rendered content of the tooltip for the current
         * trigger, based on (in order of precedence):
         * 
         * a). The string&#x2F;node content attribute value
         * b). From the content lookup map if it is set, or 
         * c). From the title attribute if set.
         *&#x2F;
        _setTriggerContent : function(node) {
            var content = this.get(&quot;content&quot;);
            if (content &amp;&amp; !(content instanceof Node || Lang.isString(content))) {
                content = content[node.get(&quot;id&quot;)] || node.getAttribute(&quot;title&quot;);
            }
            this.setTriggerContent(content);
        },

        &#x2F;*
         * Set the currently bound trigger node information, clearing 
         * out the title attribute if set and setting up mousemove&#x2F;out 
         * listeners.
         *&#x2F;
        _setCurrentTrigger : function(node, x, y) {

            var currTrigger = this._currTrigger,
                triggerHandles = this._eventHandles.trigger;

            this._setTriggerContent(node);

            triggerHandles.mouseMove = Y.on(&quot;mousemove&quot;, Y.bind(this._onNodeMouseMove, this), node);
            triggerHandles.mouseOut = Y.on(&quot;mouseleave&quot;, Y.bind(this._onNodeMouseLeave, this), node);

            var title = node.getAttribute(&quot;title&quot;);
            node.setAttribute(&quot;title&quot;, &quot;&quot;);

            currTrigger.mouseX = x;
            currTrigger.mouseY = y;
            currTrigger.node = node;
            currTrigger.title = title;
        },

        &#x2F;*
         * Clear out the current trigger state, restoring
         * the title attribute on the trigger node, 
         * if it was originally set.
         *&#x2F;
        _clearCurrentTrigger : function() {

            var currTrigger = this._currTrigger,
                triggerHandles = this._eventHandles.trigger;

            if (currTrigger.node) {
                var node = currTrigger.node;
                var title = currTrigger.title || &quot;&quot;;

                currTrigger.node = null;
                currTrigger.title = &quot;&quot;;

                triggerHandles.mouseMove.detach();
                triggerHandles.mouseOut.detach();
                triggerHandles.mouseMove = null;
                triggerHandles.mouseOut = null;

                node.setAttribute(&quot;title&quot;, title);
            }
        },

        &#x2F;*
         * Cancel any existing show&#x2F;hide timers
         *&#x2F;
        _clearTimers : function() {
            var timers = this._timers;
            if (timers.hide) {
                timers.hide.cancel();
                timers.hide = null;
            }
            if (timers.show) {
              timers.show.cancel();
              timers.show = null;
            }
        },

        &#x2F;*
         * Detach any stored event handles
         *&#x2F;
        _clearHandles : function() {
            var eventHandles = this._eventHandles;

            if (eventHandles.delegate) {
                this._eventHandles.delegate.detach();
            }
            if (eventHandles.trigger.mouseOut) {
                eventHandles.trigger.mouseOut.detach();
            }
            if (eventHandles.trigger.mouseMove) {
                eventHandles.trigger.mouseMove.detach();
            }
        }
    }, {
    
        &#x2F;&#x2F; STATIC METHODS&#x2F;PROPERTIES
       
        OFFSET_X : 15,
        OFFSET_Y : 15,
        OFFSCREEN_X : OX,
        OFFSCREEN_Y : OY,

        ATTRS : {
    
            &#x2F;* 
             * The tooltip content. This can either be a fixed content value, 
             * or a map of id-to-values, designed to be used when a single
             * tooltip is mapped to multiple trigger elements.
             *&#x2F;
            content : {
                value: null
            },
    
            &#x2F;* 
             * The set of nodes to bind to the tooltip instance. Can be a string, 
             * or a node instance.
             *&#x2F;
            triggerNodes : {
                value: null,
                setter: function(val) {
                    if (val &amp;&amp; Lang.isString(val)) {
                        val = Node.all(val);
                    }
                    return val;
                }
            },
    
            &#x2F;*
             * The delegate node to which event listeners should be attached.
             * This node should be an ancestor of all trigger nodes bound
             * to the instance. By default the document is used.
             *&#x2F;
            delegate : {
                value: null,
                setter: function(val) {
                    return Y.one(val) || Y.one(&quot;document&quot;);
                }
            },
    
            &#x2F;*
             * The time to wait, after the mouse enters the trigger node,
             * to display the tooltip
             *&#x2F;
            showDelay : {
                value:250
            },
    
            &#x2F;*
             * The time to wait, after the mouse leaves the trigger node,
             * to hide the tooltip
             *&#x2F;
            hideDelay : {
                value:10
            },
    
            &#x2F;*
             * The time to wait, after the tooltip is first displayed for 
             * a trigger node, to hide it, if the mouse has not left the 
             * trigger node
             *&#x2F;
            autoHideDelay : {
                value:2000
            },
    
            &#x2F;*
             * Override the default visibility set by the widget base class
             *&#x2F;
            visible : {
                value:false
            },
    
            &#x2F;*
             * Override the default XY value set by the widget base class,
             * to position the tooltip offscreen
             *&#x2F;
            xy: {
                value:[OX, OY]
            }
        }
    });

    var tt = new Tooltip({
        triggerNodes:&quot;.yui3-hastooltip&quot;,
        delegate: &quot;#delegate&quot;,
        content: {
            tt3: &quot;Tooltip 3 (from lookup)&quot;
        },
        shim:false,
        zIndex:2
    });
    tt.render();

    tt.on(&quot;triggerEnter&quot;, function(e) {
        var node = e.node;
        if (node &amp;&amp; node.get(&quot;id&quot;) == &quot;tt2&quot;) {
            this.setTriggerContent(&quot;Tooltip 2 (from triggerEvent)&quot;);
        }
    });

    var prevent = Y.one(&quot;#prevent&quot;);
    tt.on(&quot;triggerEnter&quot;, function(e) {
        var node = e.node;
        if (prevent.get(&quot;checked&quot;)) {
            if (node &amp;&amp; node.get(&quot;id&quot;) == &quot;tt4&quot;) {
                e.preventDefault();
            }
        }
    });
});
&lt;&#x2F;script&gt;</pre>

</div>
            </div>
        </div>

        <div class="yui3-u-1-4">
            <div class="sidebar">
                

                
                    <div class="sidebox">
                        <div class="hd">
                            <h2 class="no-toc">Examples</h2>
                        </div>

                        <div class="bd">
                            <ul class="examples">
                                
                                    
                                        <li data-description="Shows how to extend the base widget class, to create your own Widgets.">
                                            <a href="widget-extend.html">Extending the Base Widget Class</a>
                                        </li>
                                    
                                
                                    
                                        <li data-description="Shows how to use Base.create and mix/match extensions to create custom Widget classes.">
                                            <a href="widget-build.html">Creating Custom Widget Classes With Extensions</a>
                                        </li>
                                    
                                
                                    
                                        <li data-description="Shows how to create an IO plugin for Widget.">
                                            <a href="widget-plugin.html">Creating a Widget Plugin</a>
                                        </li>
                                    
                                
                                    
                                        <li data-description="Shows how to extend the Widget class, and add WidgetPosition and WidgetStack to create a Tooltip widget class.">
                                            <a href="widget-tooltip.html">Creating a Simple Tooltip Widget With Extensions</a>
                                        </li>
                                    
                                
                                    
                                        <li data-description="Shows how to extend the Widget class, and add WidgetParent and WidgetChild to create a simple ListBox widget.">
                                            <a href="widget-parentchild-listbox.html">Creating a Hierarchical ListBox Widget</a>
                                        </li>
                                    
                                
                            </ul>
                        </div>
                    </div>
                

                
            </div>
        </div>
    </div>
</div>

<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>

</body>
</html>
