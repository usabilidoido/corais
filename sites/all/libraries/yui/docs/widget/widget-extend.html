<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Example: Extending the Base Widget Class</title>
    <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Maven+Pro:400,700">
    <link rel="stylesheet" href="../../build/cssgrids/grids-min.css">
    <link rel="stylesheet" href="../assets/css/main.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <script src="../../build/yui/yui-min.js"></script>
</head>
<body>

<div id="doc">
    <h1>Example: Extending the Base Widget Class</h1>

    

    <div class="yui3-g">
        <div class="yui3-u-3-4">
            <div id="main">
                <div class="content"><style type="text/css" scoped>
    .yui3-js-enabled .yui3-spinner-loading {
        display:none;
    }

    .yui3-spinner-hidden {
        display:none;
    }

    .yui3-spinner {
        display:-moz-inline-stack;
        display:inline-block;
        zoom:1;
        *display:inline;
        vertical-align:middle;
    }

    .yui3-spinner-content {
        padding:1px;
        position:relative;
    }

    .yui3-spinner-value {
        width:2em;
        height:1.5em;
        text-align:right;
        margin-right:22px;
        vertical-align:top;
        border:1px solid #000;
        padding:2px;
    }

    .yui3-spinner-increment, .yui3-spinner-decrement {
        position:absolute;
        height:1em;
        width:22px;
        overflow:hidden;
        text-indent:-10em;
        border:1px solid #999;
        margin:0;
        padding:0px;
    }

    .yui3-spinner-increment {
        top:1px;
        *top:2px;
        right:1px;
        background:#ddd url(../assets/widget/arrows.png) no-repeat 50% 0px;
    }

     .yui3-spinner-decrement {
        bottom:1px;
        *bottom:2px;
        right:1px;
        background:#ddd url(../assets/widget/arrows.png) no-repeat 50% -20px;
     }

    #widget-extend-example {
        padding:5px;
    }

    #widget-extend-example .hint {
        margin-top:10px;
        font-size:85%;
        color:#00a;
    }

</style>

<div class="intro">
    <p>This example shows how to extend the base <code>Widget</code> class to create a simple, re-usable spinner control. The <code>Spinner</code> class created in the example is not intended to be a fully featured spinner. It is used here as a concrete example, to convey some of the key concepts to keep in mind when extending the <code>Widget</code> class.</p>
</div>

<div class="example">
    <div id="widget-extend-example">
    A basic spinner widget: <input type="text" id="numberField" class="yui3-spinner-loading" value="20" />
    <p class="hint">Click the buttons, or the arrow up/down and page up/down keys on your keyboard to change the spinner's value</p>
</div>

<script type="text/javascript">
YUI().use("event-key", "widget", function(Y) {

    var Lang = Y.Lang,
        Widget = Y.Widget,
        Node = Y.Node;

    /* Spinner class constructor */
    function Spinner(config) {
        Spinner.superclass.constructor.apply(this, arguments);
    }

    /* 
     * Required NAME static field, to identify the Widget class and 
     * used as an event prefix, to generate class names etc. (set to the 
     * class name in camel case). 
     */
    Spinner.NAME = "spinner";

    /*
     * The attribute configuration for the Spinner widget. Attributes can be
     * defined with default values, get/set functions and validator functions
     * as with any other class extending Base.
     */
    Spinner.ATTRS = {
        // The minimum value for the spinner.
        min : {
            value:0
        },

        // The maximum value for the spinner.
        max : {
            value:100
        },

        // The current value of the spinner.
        value : {
            value:0,
            validator: function(val) {
                return this._validateValue(val);
            }
        },

        // Amount to increment/decrement the spinner when the buttons or arrow up/down keys are pressed.
        minorStep : {
            value:1
        },

        // Amount to increment/decrement the spinner when the page up/down keys are pressed.
        majorStep : {
            value:10
        },

        // override default ("null"), required for focus()
        tabIndex: {
            value: 0
        },

        // The strings for the spinner UI. This attribute is 
        // defined by the base Widget class but has an empty value. The
        // spinner is simply providing a default value for the attribute.
        strings: {
            value: {
                tooltip: "Press the arrow up/down keys for minor increments, page up/down for major increments.",
                increment: "Increment",
                decrement: "Decrement"
            }
        }
    };

    /* Static constant used to identify the classname applied to the spinners value field */
    Spinner.INPUT_CLASS = Y.ClassNameManager.getClassName(Spinner.NAME, "value");

    /* Static constants used to define the markup templates used to create Spinner DOM elements */
    Spinner.INPUT_TEMPLATE = '<input type="text" class="' + Spinner.INPUT_CLASS + '">';
    Spinner.BTN_TEMPLATE = '<button type="button"></button>';

    /* 
     * The HTML_PARSER static constant is used by the Widget base class to populate 
     * the configuration for the spinner instance from markup already on the page.
     *
     * The Spinner class attempts to set the value of the spinner widget if it
     * finds the appropriate input element on the page.
     */
    Spinner.HTML_PARSER = {
        value: function (srcNode) {
            var val = parseInt(srcNode.get("value")); 
            return Y.Lang.isNumber(val) ? val : null;
        }
    };

    /* Spinner extends the base Widget class */
    Y.extend(Spinner, Widget, {

        /*
         * initializer is part of the lifecycle introduced by 
         * the Widget class. It is invoked during construction,
         * and can be used to setup instance specific state.
         * 
         * The Spinner class does not need to perform anything
         * specific in this method, but it is left in as an example.
         */
        initializer: function() {
            // Not doing anything special during initialization
        },

        /*
         * destructor is part of the lifecycle introduced by 
         * the Widget class. It is invoked during destruction,
         * and can be used to cleanup instance specific state.
         * 
         * The spinner cleans up any node references it's holding
         * onto. The Widget classes destructor will purge the 
         * widget's bounding box of event listeners, so spinner 
         * only needs to clean up listeners it attaches outside of 
         * the bounding box.
         */
        destructor : function() {
            this._documentMouseUpHandle.detach();

            this.inputNode = null;
            this.incrementNode = null;
            this.decrementNode = null;
        },

        /*
         * renderUI is part of the lifecycle introduced by the
         * Widget class. Widget's renderer method invokes:
         *
         *     renderUI()
         *     bindUI()
         *     syncUI()
         *
         * renderUI is intended to be used by the Widget subclass
         * to create or insert new elements into the DOM. 
         *
         * For spinner the method adds the input (if it's not already 
         * present in the markup), and creates the inc/dec buttons
         */
        renderUI : function() {
            this._renderInput();
            this._renderButtons();
        },

        /*
         * bindUI is intended to be used by the Widget subclass 
         * to bind any event listeners which will drive the Widget UI.
         * 
         * It will generally bind event listeners for attribute change
         * events, to update the state of the rendered UI in response 
         * to attribute value changes, and also attach any DOM events,
         * to activate the UI.
         * 
         * For spinner, the method:
         *
         * - Sets up the attribute change listener for the "value" attribute
         *
         * - Binds key listeners for the arrow/page keys
         * - Binds mouseup/down listeners on the boundingBox, document respectively.
         * - Binds a simple change listener on the input box.
         */
        bindUI : function() {
            this.after("valueChange", this._afterValueChange);

            var boundingBox = this.get("boundingBox");

            // Looking for a key event which will fire continuously across browsers while the key is held down. 38, 40 = arrow up/down, 33, 34 = page up/down
            var keyEventSpec = (!Y.UA.opera) ? "down:" : "press:";
            keyEventSpec += "38, 40, 33, 34";

            Y.on("key", Y.bind(this._onDirectionKey, this), boundingBox, keyEventSpec);
            Y.on("mousedown", Y.bind(this._onMouseDown, this), boundingBox);

            this._documentMouseUpHandle = Y.on("mouseup", Y.bind(this._onDocMouseUp, this), boundingBox.get("ownerDocument"));

            Y.on("change", Y.bind(this._onInputChange, this), this.inputNode);
        },

        /*
         * syncUI is intended to be used by the Widget subclass to
         * update the UI to reflect the current state of the widget.
         * 
         * For spinner, the method sets the value of the input field,
         * to match the current state of the value attribute.
         */
        syncUI : function() {
            this._uiSetValue(this.get("value"));
        },

        /*
         * Creates the input control for the spinner and adds it to
         * the widget's content box, if not already in the markup.
         */
        _renderInput : function() {
            var contentBox = this.get("contentBox"),
                input = contentBox.one("." + Spinner.INPUT_CLASS),
                strings = this.get("strings");

            if (!input) {
                input = Node.create(Spinner.INPUT_TEMPLATE);
                contentBox.appendChild(input);
            }

            input.set("title", strings.tooltip);
            this.inputNode = input;
        },

        /*
         * Creates the button controls for the spinner and add them to
         * the widget's content box, if not already in the markup.
         */
        _renderButtons : function() {
            var contentBox = this.get("contentBox"),
                strings = this.get("strings");

            var inc = this._createButton(strings.increment, this.getClassName("increment"));
            var dec = this._createButton(strings.decrement, this.getClassName("decrement"));

            this.incrementNode = contentBox.appendChild(inc);
            this.decrementNode = contentBox.appendChild(dec);
        },

        /*
         * Utility method, to create a spinner button
         */
        _createButton : function(text, className) {

            var btn = Y.Node.create(Spinner.BTN_TEMPLATE);
            btn.set("innerHTML", text);
            btn.set("title", text);
            btn.addClass(className);

            return btn;
        },

        /*
         * Bounding box mouse down handler. Will determine if the mouse down
         * is on one of the spinner buttons, and increment/decrement the value
         * accordingly.
         * 
         * The method also sets up a timer, to support the user holding the mouse
         * down on the spinner buttons. The timer is cleared when a mouse up event
         * is detected.
         */
        _onMouseDown : function(e) {
            var node = e.target,
                dir,
                handled = false,
                currVal = this.get("value"),
                minorStep = this.get("minorStep");

            if (node.hasClass(this.getClassName("increment"))) {
                this.set("value", currVal + minorStep);
                dir = 1;
                handled = true;
            } else if (node.hasClass(this.getClassName("decrement"))) {
                this.set("value", currVal - minorStep);
                dir = -1;
                handled = true;
            }

            if (handled) {
                this._setMouseDownTimers(dir, minorStep);
            }
        },

        /*
         * Override the default content box value, since we don't want the srcNode
         * to be the content box for spinner.
         */
        _defaultCB : function() {
            return null;
        },

        /*
         * Document mouse up handler. Clears the timers supporting
         * the "mouse held down" behavior.
         */
        _onDocMouseUp : function(e) {
            this._clearMouseDownTimers();
        },

        /*
         * Bounding box Arrow up/down, Page up/down key listener.
         *
         * Increments/Decrement the spinner value, based on the key pressed.
         */
        _onDirectionKey : function(e) {

            e.preventDefault();

            var currVal = this.get("value"),
                newVal = currVal,
                minorStep = this.get("minorStep"),
                majorStep = this.get("majorStep");

            switch (e.charCode) {
                case 38:
                    newVal += minorStep;
                    break;
                case 40:
                    newVal -= minorStep;
                    break;
                case 33:
                    newVal += majorStep;
                    newVal = Math.min(newVal, this.get("max"));
                    break;
                case 34:
                    newVal -= majorStep;
                    newVal = Math.max(newVal, this.get("min"));
                    break;
            }

            if (newVal !== currVal) {
                this.set("value", newVal);
            }
        },

        /*
         * Simple change handler, to make sure user does not input an invalid value
         */
        _onInputChange : function(e) {
            if (!this._validateValue(this.inputNode.get("value"))) {
                this.syncUI();
            }
        },

        /*
         * Initiates mouse down timers, to increment slider, while mouse button
         * is held down
         */
        _setMouseDownTimers : function(dir, step) {
            this._mouseDownTimer = Y.later(500, this, function() {
                this._mousePressTimer = Y.later(100, this, function() {
                    this.set("value", this.get("value") + (dir * step));
                }, null, true)
            });
        },

        /*
         * Clears timers used to support the "mouse held down" behavior
         */
        _clearMouseDownTimers : function() {
            if (this._mouseDownTimer) {
                this._mouseDownTimer.cancel();
                this._mouseDownTimer = null;
            }
            if (this._mousePressTimer) {
                this._mousePressTimer.cancel();
                this._mousePressTimer = null;
            }
        },

        /*
         * value attribute change listener. Updates the 
         * value in the rendered input box, whenever the 
         * attribute value changes.
         */
        _afterValueChange : function(e) {
            this._uiSetValue(e.newVal);
        },

        /*
         * Updates the value of the input box to reflect 
         * the value passed in
         */
        _uiSetValue : function(val) {
            this.inputNode.set("value", val);
        },

        /*
         * value attribute default validator. Verifies that
         * the value being set lies between the min/max value
         */
        _validateValue: function(val) {
            var min = this.get("min"),
                max = this.get("max");

            return (Lang.isNumber(val) && val >= min && val <= max);
        }
    });

    // Create a new Spinner instance, drawing it's 
    // starting value from an input field already on the 
    // page (the #numberField text box)
    var spinner = new Spinner({
        srcNode: "#numberField",
        max:100,
        min:0
    });
    spinner.render();
    spinner.focus();
});
</script>

</div>

<h2>Extending The <code>Widget</code> Class</h2>

<h3>Basic Class Structure</h3>

<p>Widgets classes follow the general pattern implemented by the <code>Spinner</code> class, shown in the code snippet below. The basic pattern for setting up a new widget class involves:</p>

<ol>
    <li>Defining the constructor function for the new widget class, which invokes the superclass constructor to kick off the initialization chain <em>(line 2)</em></li>
    <li>Defining the static <code>NAME</code> property for the class, which is normally the class name in camel case, and is used to prefix events and CSS classes fired/created by the class <em>(line 11)</em></li>
    <li>Defining the static <code>ATTRS</code> property for the class, which defines the set of attributes which the class will introduce, in addition to the superclass attributes <em>(line 18-57)</em></li>
    <li>Extending the <code>Widget</code> class, and adding/overriding any prototype properties/methods <em>(line 61)</em></li>
</ol>

<pre class="code prettyprint">&#x2F;* Spinner class constructor *&#x2F;
function Spinner(config) {
    Spinner.superclass.constructor.apply(this, arguments);
}

&#x2F;* 
 * Required NAME static field, to identify the Widget class and 
 * used as an event prefix, to generate class names etc. (set to the 
 * class name in camel case). 
 *&#x2F;
Spinner.NAME = &quot;spinner&quot;;

&#x2F;*
 * The attribute configuration for the Spinner widget. Attributes can be
 * defined with default values, get&#x2F;set functions and validator functions
 * as with any other class extending Base.
 *&#x2F;
Spinner.ATTRS = {
    &#x2F;&#x2F; The minimum value for the spinner.
    min : {
        value:0
    },

    &#x2F;&#x2F; The maximum value for the spinner.
    max : {
        value:100
    },

    &#x2F;&#x2F; The current value of the spinner.
    value : {
        value:0,
        validator: function(val) {
            return this._validateValue(val);
        }
    },

    &#x2F;&#x2F; Amount to increment&#x2F;decrement the spinner when the buttons, 
    &#x2F;&#x2F; or arrow up&#x2F;down keys are pressed.
    minorStep : {
        value:1
    },

    &#x2F;&#x2F; Amount to increment&#x2F;decrement the spinner when the page up&#x2F;down keys are pressed.
    majorStep : {
        value:10
    },

    &#x2F;&#x2F; The localizable strings for the spinner. This attribute is 
    &#x2F;&#x2F; defined by the base Widget class but has an empty value. The
    &#x2F;&#x2F; spinner is simply providing a default value for the attribute.
    strings: {
        value: {
            tooltip: &quot;Press the arrow up&#x2F;down keys for minor increments, \ 
                      page up&#x2F;down for major increments.&quot;,
            increment: &quot;Increment&quot;,
            decrement: &quot;Decrement&quot;
        }
    }
};

Y.extend(Spinner, Widget, {
    &#x2F;&#x2F; Methods&#x2F;properties to add to the prototype of the new class
    ...
});</pre>


<p>Note that these steps are the same for any class which is derived from <a href="../base/index.html"><code>Base</code></a>, nothing Widget-specific is involved yet. 
Widget adds the concept of a rendered UI to the existing Base lifecycle (viz. init, destroy and attribute state configuration), which we'll see show up in Widget-specific areas below.</p>

<h4>A Note On Externalizing Strings and Internationalization</h4>

<p>For the scope of this example we won't get into packaging your custom widget code as a YUI module, but when you do, you can leverage the <a href="../intl/index.html">Internationalization</a> infrastructure 
to bundle the strings for your widget separately from the code, and avoid hard-coding them into the widget's code base as we're doing above.</p>

<p>When packaged separately from the code, the <code>strings</code> attribute can be changed to be:</p>

<pre class="code prettyprint">Spinner.ATTRS = {
    ...
    strings : {
        valueFn : function() {
            return Y.Intl.get(&quot;myspinner&quot;); &#x2F;&#x2F; Assuming &quot;myspinner&quot; is the name of your widget&#x27;s module. 
        }        
    } 
    ...
}</pre>


<p>Loader will deliver the language specific bundle for your widget along with the code when someone uses your <code>myspinner</code> module. The language specific strings can be retrieved through the <code>Y.Intl.get(modulename)</code> call.</p>

<p>The <a href="../intl/intl-basic.html">Language Resource Bundles</a> example goes into more detail about the structure of the langauge bundles, how they are built and how to configure your YUI instance to deliver them. <a href="https://github.com/yui/yui3/tree/master/build/calendar-base">Calendar's source code</a> is also a good example of how this infrastructure is used.</p>

<h3>The HTML_PARSER Property</h3>

<p>
The first Widget-specific property <code>Spinner</code> implements is the static <a href="http://yuilibrary.com/yui/docs/api/Widget.html#property_Widget.HTML_PARSER"><code>HTML_PARSER</code></a> property. It is used to set the initial widget configuration based on markup, providing basic progressive enhancement support.
</p>
<p> 
The value of the <code>HTML_PARSER</code> property is an object literal, where each property is a widget attribute name, and the value is either a selector string (if the attribute is a node reference) or a function which is executed to provide 
a value for the attribute from the markup on the page. Markup is essentially thought of as an additional data source for the user to set initial attribute values, outside of the configuration object passed to the constructor 
<em>(values passed to the constructor will take precedence over values picked up from markup)</em>.
</p>

<p>For <code>Spinner</code>, <code>HTML_PARSER</code> defines a function for the <code>value</code> attribute, which sets the initial value of the spinner based on an input field if present in the markup.</p>

<pre class="code prettyprint">&#x2F;* 
 * The HTML_PARSER static constant is used by the Widget base class to populate 
 * the configuration for the spinner instance from markup already on the page.
 *
 * The Spinner class attempts to set the value of the spinner widget if it
 * finds the appropriate input element on the page.
 *&#x2F;
Spinner.HTML_PARSER = {
    value: function (contentBox) {
        var node = contentBox.one(&quot;.&quot; + Spinner.INPUT_CLASS);
        return (node) ? parseInt(node.get(&quot;value&quot;)) : null;
    }
};</pre>


<h3>Lifecycle Methods: initializer, destructor</h3>

<p>The <code>initializer</code> and <code>destructor</code> lifecycle methods are carried over from <code>Base</code>, and can be used to set up initial state during construction, and clean up state during destruction respectively.</p>

<p>For <code>Spinner</code>, there is nothing special we need to do in the <code>initializer</code> (attribute setup is already taken care of), but it's left in the example to round out the lifecycle discussion.</p>

<p>The <code>destructor</code> takes care of detaching any event listeners <code>Spinner</code> adds outside of the bounding box (event listeners on/inside the bounding box are purged by <code>Widget</code>'s <code>destructor</code>).</p>

<pre class="code prettyprint">&#x2F;*
 * initializer is part of the lifecycle introduced by 
 * the Widget class. It is invoked during construction,
 * and can be used to set up instance specific state.
 *  
 * The Spinner class does not need to perform anything
 * specific in this method, but it is left in as an example.
 *&#x2F;
initializer: function(config) {
    &#x2F;&#x2F; Not doing anything special during initialization
},

&#x2F;*
 * destructor is part of the lifecycle introduced by 
 * the Widget class. It is invoked during destruction,
 * and can be used to clean up instance specific state.
 * 
 * The spinner cleans up any node references it&#x27;s holding
 * onto. The Widget classes destructor will purge the 
 * widget&#x27;s bounding box of event listeners, so spinner 
 * only needs to clean up listeners it attaches outside of 
 * the bounding box.
 *&#x2F;
destructor : function() {
    this._documentMouseUpHandle.detach();

    this.inputNode = null;
    this.incrementNode = null;
    this.decrementNode = null;
}</pre>


<h3>Rendering Lifecycle Methods: renderer, renderUI, bindUI, syncUI</h3>

<p>Widget adds a <code>render</code> method to the <code>init</code> and <code>destroy</code> lifecycle methods provided by Base. The <code>init</code> and <code>destroy</code> methods invoke the corresponding <code>initializer</code> and <code>destructor</code> implementations for the widget. Similarly, the <code>render</code> method invokes the <code>renderer</code> implementation for the widget. Note that the <code>renderer</code> method is not chained automatically, unlike the <code>initializer</code> and <code>destructor</code> methods.</p>

<p>The <code>Widget</code> class already provides a default <code>renderer</code> implementation, which invokes the following abstract methods in the order shown <em>(with their respective responsibilities)</em>:</p>

<ol>
    <li><code>renderUI()</code> : responsible for creating/adding elements to the DOM to render the widget.</li>
    <li><code>bindUI()</code> : responsible for binding event listeners (both attribute change and DOM event listeners) to 'activate' the rendered UI.</li>
    <li><code>syncUI()</code> : responsible for updating the rendered UI based on the current state of the widget.</li>
</ol>

<p>Since the <code>Spinner</code> class has no need to modify the <code>Widget</code> <code>renderer</code> implementation, it simply implements the above 3 methods to handle the render phase:</p>

<pre class="code prettyprint">&#x2F;*
 * For spinner the method adds the input (if it&#x27;s not already 
 * present in the markup), and creates the increment&#x2F;decrement buttons
 *&#x2F;
renderUI : function() {
    this._renderInput();
    this._renderButtons();
},

&#x2F;*
 * For spinner, the method:
 *
 * - Sets up the attribute change listener for the &quot;value&quot; attribute
 *
 * - Binds key listeners for the arrow&#x2F;page keys
 * - Binds mouseup&#x2F;down listeners on the boundingBox, document respectively.
 * - Binds a simple change listener on the input box.
 *&#x2F;
bindUI : function() {
    this.after(&quot;valueChange&quot;, this._afterValueChange);

    var boundingBox = this.get(&quot;boundingBox&quot;);

    &#x2F;&#x2F; Looking for a key event which will fire continuously across browsers 
    &#x2F;&#x2F; while the key is held down. 38, 40 = arrow up&#x2F;down, 33, 34 = page up&#x2F;down
    var keyEventSpec = (!Y.UA.opera) ? &quot;down:&quot; : &quot;press:&quot;;
    keyEventSpec += &quot;38, 40, 33, 34&quot;;


    Y.on(&quot;change&quot;, Y.bind(this._onInputChange, this), this.inputNode);
    Y.on(&quot;key&quot;, Y.bind(this._onDirectionKey, this), boundingBox, keyEventSpec);
    Y.on(&quot;mousedown&quot;, Y.bind(this._onMouseDown, this), boundingBox);
    this._documentMouseUpHandle = Y.on(&quot;mouseup&quot;, Y.bind(this._onDocMouseUp, this), 
                boundingBox.get(&quot;ownerDocument&quot;));
},

&#x2F;*
 * For spinner, the method sets the value of the input field,
 * to match the current state of the value attribute.
 *&#x2F;
syncUI : function() {
    this._uiSetValue(this.get(&quot;value&quot;));
}</pre>


<h4>A Note On Key Event Listeners</h4>

<p>The <code>Spinner</code> uses Event's <code>&quot;key&quot;</code> support, to set up a listener for arrow up/down and page up/down keys on the spinner's bounding box (line 31).</p>

<p>Event's <code>&quot;key&quot;</code> support allows <code>Spinner</code> to define a single listener, which is only invoked for the key specification provided. The key specification in the above use case is <code>&quot;down:38, 40, 33, 34&quot;</code> for most browsers, indicating that 
the <code>_onDirectionKey</code> method should only be called if the bounding box receives a keydown event with a character code which is either 38, 40, 33 or 34. <code>&quot;key&quot;</code> specifications can also contain more <a href="http://yuilibrary.com/yui/docs/api/YUI.html#event_key">advanced filter criteria</a>, involving modifiers such as CTRL and SHIFT.</p>

<p>For the Spinner widget, we're looking for a key event which fires repeatedly while the key is held down. This differs for Opera, so we need to fork for the key event we're interested in. Future versions of <code>&quot;key&quot;</code> support will aim to provide this type of higher level cross-browser abstraction also.</p>

<h3>Attribute Supporting Methods</h3>

<p>Since all widgets are attribute-driven, they all follow a pretty similar pattern when it comes to how those attributes are used. For a given attribute, widgets will generally have:</p>
<ul>
    <li>A prototype method to listen for changes in the attribute</li>
    <li>A prototype method to update the state of the rendered UI, to reflect the value of an attribute.</li>
    <li>A prototype method used to set/get/validate the attribute.</li>
</ul>

<p>These methods are kept on the prototype to facilitate customization at any of the levels - event handling, ui updates, set/get/validation logic.</p>

<p>For <code>Spinner</code>, these corresponding methods for the <code>value</code> attribute are: <code>_afterValueChange</code>, <code>_uiSetValue</code> and <code>_validateValue</code>:</p>

<pre class="code prettyprint">&#x2F;*
 * value attribute change listener. Updates the 
 * value in the rendered input box, whenever the 
 * attribute value changes.
 *&#x2F;
_afterValueChange : function(e) {
    this._uiSetValue(e.newVal);
},

&#x2F;*
 * Updates the value of the input box to reflect 
 * the value passed in
 *&#x2F;
_uiSetValue : function(val) {
    this.inputNode.set(&quot;value&quot;, val);
},

&#x2F;*
 * value attribute default validator. Verifies that
 * the value being set lies between the min&#x2F;max value
 *&#x2F;
_validateValue: function(val) {
    var min = this.get(&quot;min&quot;),
        max = this.get(&quot;max&quot;);

    return (Lang.isNumber(val) &amp;&amp; val &gt;= min &amp;&amp; val &lt;= max);
}</pre>


<p>Since this example focuses on general patterns for widget development, validator/set/get functions are not defined for attributes such as min/max in the interests of keeping the example simple, but could be, in a production ready spinner.</p>

<h3>Rendering Support Methods</h3>

<p><code>Spinner</code>'s <code>renderUI</code> method hands off creation of the input field and buttons to the following helpers which use markup templates to generate node instances:</p>

<pre class="code prettyprint">&#x2F;*
 * Creates the input field for the spinner and adds it to
 * the widget&#x27;s content box, if not already in the markup.
 *&#x2F;
_renderInput : function() {
    var contentBox = this.get(&quot;contentBox&quot;),
        input = contentBox.one(&quot;.&quot; + Spinner.INPUT_CLASS),
        strings = this.get(&quot;strings&quot;);

    if (!input) {
        input = Node.create(Spinner.INPUT_TEMPLATE);
        contentBox.appendChild(input);
    }

    input.set(&quot;title&quot;, strings.tooltip);
    this.inputNode = input;
},

&#x2F;*
 * Creates the button controls for the spinner and adds them to
 * the widget&#x27;s content box, if not already in the markup.
 *&#x2F;
_renderButtons : function() {
    var contentBox = this.get(&quot;contentBox&quot;),
        strings = this.get(&quot;strings&quot;);

    var inc = this._createButton(strings.increment, this.getClassName(&quot;increment&quot;));
    var dec = this._createButton(strings.decrement, this.getClassName(&quot;decrement&quot;));

    this.incrementNode = contentBox.appendChild(inc);
    this.decrementNode = contentBox.appendChild(dec);
},

&#x2F;*
 * Utility method, to create a spinner button
 *&#x2F;
_createButton : function(text, className) {

    var btn = Y.Node.create(Spinner.BTN_TEMPLATE);
    btn.set(&quot;innerHTML&quot;, text);
    btn.set(&quot;title&quot;, text);
    btn.addClass(className);

    return btn;
}</pre>


<h3>DOM Event Listeners</h3>

<p>The DOM event listeners attached during <code>bindUI</code> are straightforward event listeners, which receive the event facade for the DOM event, and update the spinner state accordingly.</p>

<p>A couple of interesting points worth noting: In the <code>&quot;key&quot;</code> listener we set up, we can call <code>e.preventDefault()</code> without having to check the character code, since the <code>&quot;key&quot;</code> event specifier will only invoke the listener 
if one of the specified keys is pressed (arrow/page up/down)</p>

<p>Also, to allow the spinner to update its value while the mouse button is held down, we set up a timer, which gets cleared out when we receive a mouseup event on the document.</p>

<pre class="code prettyprint">&#x2F;*
 * Bounding box Arrow up&#x2F;down, Page up&#x2F;down key listener.
 *
 * Increments&#x2F;Decrements the spinner value, based on the key pressed.
 *&#x2F;
_onDirectionKey : function(e) {
    e.preventDefault();
    ...
    switch (e.charCode) {
        case 38:
            newVal += minorStep;
            break;
        case 40:
            newVal -= minorStep;
            break;
        case 33:
            newVal += majorStep;
            newVal = Math.min(newVal, this.get(&quot;max&quot;));
            break;
        case 34:
            newVal -= majorStep;
            newVal = Math.max(newVal, this.get(&quot;min&quot;));
            break;
    }

    if (newVal !== currVal) {
        this.set(&quot;value&quot;, newVal);
    }
},

&#x2F;*
 * Bounding box mouse down handler. Will determine if the mouse down
 * is on one of the spinner buttons, and increment&#x2F;decrement the value
 * accordingly.
 * 
 * The method also sets up a timer, to support the user holding the mouse
 * down on the spinner buttons. The timer is cleared when a mouse up event
 * is detected.
 *&#x2F;
_onMouseDown : function(e) {
    var node = e.target
    ...
    if (node.hasClass(this.getClassName(&quot;increment&quot;))) {
        this.set(&quot;value&quot;, currVal + minorStep);
        ...
    } else if (node.hasClass(this.getClassName(&quot;decrement&quot;))) {
        this.set(&quot;value&quot;, currVal - minorStep);
        ...
    }

    if (handled) {
        this._setMouseDownTimers(dir);
    }
},

&#x2F;*
 * Document mouse up handler. Clears the timers supporting
 * the &quot;mouse held down&quot; behavior.
 *&#x2F;
_onDocMouseUp : function(e) {
    this._clearMouseDownTimers();
},

&#x2F;*
 * Simple change handler, to make sure user does not input an invalid value
 *&#x2F;
_onInputChange : function(e) {
    if (!this._validateValue(this.inputNode.get(&quot;value&quot;))) {
        &#x2F;&#x2F; If the entered value is not valid, re-display the stored value
        this.syncUI();
    }
}</pre>


<h3>ClassName Support Methods</h3>

<p>A key part of developing widgets which work with the DOM is defining class names which it will use to mark the nodes it renders. These class names could be used to mark a node for later retrieval/lookup, for CSS application (both functional as well as cosmetic) or to indicate the current state of the widget.</p>

<p>The widget infrastructure uses the <code>ClassNameManager</code> utility, to generate consistently named classes to apply to the nodes it adds to the page:</p>

<pre class="code prettyprint">Y.ClassNameManager.getClassName(Spinner.NAME, &quot;value&quot;);
...
this.getClassName(&quot;increment&quot;);</pre>


<p>
Class names generated by the Widget's <code>getClassName</code> prototype method use the NAME field of the widget, to generate a prefixed classname through <code>ClassNameManager</code> - e.g. for spinner the <code>this.getClassName(&quot;increment&quot;)</code> above will generate the class name <code>yui3-spinner-increment</code> ("yui" being the system level prefix, "spinner" being the widget name).
When you need to generate standard class names in static code (where you don't have a reference to <code>this.getClassName()</code>), you can use the ClassNameManager directly, as shown in line 1 above, to achieve the same results.
</p>

<h3>CSS Considerations</h3>

<p>Since widget uses the <code>getClassName</code> method to generate state-related class names and to mark the bounding box/content box of the widget (e.g. "yui3-[widgetname]-content", "yui3-[widgetname]-hidden", "yui3-[widgetname]-disabled"), we need to provide the default CSS handling for states we're interested in handling for the new Spinner widget. The "yui3-[widgetname]-hidden" class is probably one state class, which all widgets will provide implementations for.</p>

<pre class="code prettyprint">&#x2F;* Progressive enhancement support, to hide the text box, if JavaScript is enabled, while we instantiate the rich control *&#x2F;
.yui3-js-enabled .yui3-spinner-loading {
    display:none;
}

&#x2F;* Controlling show&#x2F;hide state using display (since this control is inline-block) *&#x2F;
.yui3-spinner-hidden {
    display:none;
}

&#x2F;* Bounding Box - Set the bounding box to be &quot;inline block&quot; for spinner *&#x2F;
.yui3-spinner {
    display:inline-block;
    zoom:1;
    *display:inline;
}

&#x2F;* Content Box - Start adding visual treatment for the spinner *&#x2F;
.yui3-spinner-content {
    padding:1px;
}

&#x2F;* Input Text Box, generated through getClassName(&quot;value&quot;) *&#x2F;
.yui3-spinner-value {
    ...
}

&#x2F;* Button controls, generated through getClassName(&quot;increment&quot;) *&#x2F;
.yui3-spinner-increment, .yui3-spinner-decrement {
    ...
}</pre>


<h3>Using The Spinner Widget</h3>

<p>For the example, we have an input field already on the page, which we'd like to enhance to create a Spinner instance. We mark it with a yui3-spinner-loading class, so that if JavaScript is enabled, we can hide it while we're instantiating the rich control:</p>

<pre class="code prettyprint">&lt;input type=&quot;text&quot; id=&quot;numberField&quot; class=&quot;yui3-spinner-loading&quot; value=&quot;20&quot;&gt;</pre>


<p>We provide the constructor for the Spinner with the <code>srcNode</code> which contains the input field with our initial value. The <code>HTML_PARSER</code> code we saw earlier will extract the value from the input field, and use it as the initial value for the Spinner instance:</p>

<pre class="code prettyprint">&#x2F;&#x2F; Create a new Spinner instance, drawing its 
&#x2F;&#x2F; starting value from an input field already on the 
&#x2F;&#x2F; page (the #numberField text input box)
var spinner = new Spinner({
    srcNode: &quot;#numberField&quot;,
    max:100,
    min:0
});
spinner.render();
spinner.focus();</pre>


<p>The custom widget class structure discussed above is captured in this <a href="../assets/widget/mywidget.js.txt">"MyWidget" template file</a>, which you can use as a starting point to develop your own widgets.</p>

<h2>Complete Example Source</h2>
<pre class="code prettyprint">&lt;div id=&quot;widget-extend-example&quot;&gt;
    A basic spinner widget: &lt;input type=&quot;text&quot; id=&quot;numberField&quot; class=&quot;yui3-spinner-loading&quot; value=&quot;20&quot; &#x2F;&gt;
    &lt;p class=&quot;hint&quot;&gt;Click the buttons, or the arrow up&#x2F;down and page up&#x2F;down keys on your keyboard to change the spinner&#x27;s value&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;

&lt;script type=&quot;text&#x2F;javascript&quot;&gt;
YUI().use(&quot;event-key&quot;, &quot;widget&quot;, function(Y) {

    var Lang = Y.Lang,
        Widget = Y.Widget,
        Node = Y.Node;

    &#x2F;* Spinner class constructor *&#x2F;
    function Spinner(config) {
        Spinner.superclass.constructor.apply(this, arguments);
    }

    &#x2F;* 
     * Required NAME static field, to identify the Widget class and 
     * used as an event prefix, to generate class names etc. (set to the 
     * class name in camel case). 
     *&#x2F;
    Spinner.NAME = &quot;spinner&quot;;

    &#x2F;*
     * The attribute configuration for the Spinner widget. Attributes can be
     * defined with default values, get&#x2F;set functions and validator functions
     * as with any other class extending Base.
     *&#x2F;
    Spinner.ATTRS = {
        &#x2F;&#x2F; The minimum value for the spinner.
        min : {
            value:0
        },

        &#x2F;&#x2F; The maximum value for the spinner.
        max : {
            value:100
        },

        &#x2F;&#x2F; The current value of the spinner.
        value : {
            value:0,
            validator: function(val) {
                return this._validateValue(val);
            }
        },

        &#x2F;&#x2F; Amount to increment&#x2F;decrement the spinner when the buttons or arrow up&#x2F;down keys are pressed.
        minorStep : {
            value:1
        },

        &#x2F;&#x2F; Amount to increment&#x2F;decrement the spinner when the page up&#x2F;down keys are pressed.
        majorStep : {
            value:10
        },

        &#x2F;&#x2F; override default (&quot;null&quot;), required for focus()
        tabIndex: {
            value: 0
        },

        &#x2F;&#x2F; The strings for the spinner UI. This attribute is 
        &#x2F;&#x2F; defined by the base Widget class but has an empty value. The
        &#x2F;&#x2F; spinner is simply providing a default value for the attribute.
        strings: {
            value: {
                tooltip: &quot;Press the arrow up&#x2F;down keys for minor increments, page up&#x2F;down for major increments.&quot;,
                increment: &quot;Increment&quot;,
                decrement: &quot;Decrement&quot;
            }
        }
    };

    &#x2F;* Static constant used to identify the classname applied to the spinners value field *&#x2F;
    Spinner.INPUT_CLASS = Y.ClassNameManager.getClassName(Spinner.NAME, &quot;value&quot;);

    &#x2F;* Static constants used to define the markup templates used to create Spinner DOM elements *&#x2F;
    Spinner.INPUT_TEMPLATE = &#x27;&lt;input type=&quot;text&quot; class=&quot;&#x27; + Spinner.INPUT_CLASS + &#x27;&quot;&gt;&#x27;;
    Spinner.BTN_TEMPLATE = &#x27;&lt;button type=&quot;button&quot;&gt;&lt;&#x2F;button&gt;&#x27;;

    &#x2F;* 
     * The HTML_PARSER static constant is used by the Widget base class to populate 
     * the configuration for the spinner instance from markup already on the page.
     *
     * The Spinner class attempts to set the value of the spinner widget if it
     * finds the appropriate input element on the page.
     *&#x2F;
    Spinner.HTML_PARSER = {
        value: function (srcNode) {
            var val = parseInt(srcNode.get(&quot;value&quot;)); 
            return Y.Lang.isNumber(val) ? val : null;
        }
    };

    &#x2F;* Spinner extends the base Widget class *&#x2F;
    Y.extend(Spinner, Widget, {

        &#x2F;*
         * initializer is part of the lifecycle introduced by 
         * the Widget class. It is invoked during construction,
         * and can be used to setup instance specific state.
         * 
         * The Spinner class does not need to perform anything
         * specific in this method, but it is left in as an example.
         *&#x2F;
        initializer: function() {
            &#x2F;&#x2F; Not doing anything special during initialization
        },

        &#x2F;*
         * destructor is part of the lifecycle introduced by 
         * the Widget class. It is invoked during destruction,
         * and can be used to cleanup instance specific state.
         * 
         * The spinner cleans up any node references it&#x27;s holding
         * onto. The Widget classes destructor will purge the 
         * widget&#x27;s bounding box of event listeners, so spinner 
         * only needs to clean up listeners it attaches outside of 
         * the bounding box.
         *&#x2F;
        destructor : function() {
            this._documentMouseUpHandle.detach();

            this.inputNode = null;
            this.incrementNode = null;
            this.decrementNode = null;
        },

        &#x2F;*
         * renderUI is part of the lifecycle introduced by the
         * Widget class. Widget&#x27;s renderer method invokes:
         *
         *     renderUI()
         *     bindUI()
         *     syncUI()
         *
         * renderUI is intended to be used by the Widget subclass
         * to create or insert new elements into the DOM. 
         *
         * For spinner the method adds the input (if it&#x27;s not already 
         * present in the markup), and creates the inc&#x2F;dec buttons
         *&#x2F;
        renderUI : function() {
            this._renderInput();
            this._renderButtons();
        },

        &#x2F;*
         * bindUI is intended to be used by the Widget subclass 
         * to bind any event listeners which will drive the Widget UI.
         * 
         * It will generally bind event listeners for attribute change
         * events, to update the state of the rendered UI in response 
         * to attribute value changes, and also attach any DOM events,
         * to activate the UI.
         * 
         * For spinner, the method:
         *
         * - Sets up the attribute change listener for the &quot;value&quot; attribute
         *
         * - Binds key listeners for the arrow&#x2F;page keys
         * - Binds mouseup&#x2F;down listeners on the boundingBox, document respectively.
         * - Binds a simple change listener on the input box.
         *&#x2F;
        bindUI : function() {
            this.after(&quot;valueChange&quot;, this._afterValueChange);

            var boundingBox = this.get(&quot;boundingBox&quot;);

            &#x2F;&#x2F; Looking for a key event which will fire continuously across browsers while the key is held down. 38, 40 = arrow up&#x2F;down, 33, 34 = page up&#x2F;down
            var keyEventSpec = (!Y.UA.opera) ? &quot;down:&quot; : &quot;press:&quot;;
            keyEventSpec += &quot;38, 40, 33, 34&quot;;

            Y.on(&quot;key&quot;, Y.bind(this._onDirectionKey, this), boundingBox, keyEventSpec);
            Y.on(&quot;mousedown&quot;, Y.bind(this._onMouseDown, this), boundingBox);

            this._documentMouseUpHandle = Y.on(&quot;mouseup&quot;, Y.bind(this._onDocMouseUp, this), boundingBox.get(&quot;ownerDocument&quot;));

            Y.on(&quot;change&quot;, Y.bind(this._onInputChange, this), this.inputNode);
        },

        &#x2F;*
         * syncUI is intended to be used by the Widget subclass to
         * update the UI to reflect the current state of the widget.
         * 
         * For spinner, the method sets the value of the input field,
         * to match the current state of the value attribute.
         *&#x2F;
        syncUI : function() {
            this._uiSetValue(this.get(&quot;value&quot;));
        },

        &#x2F;*
         * Creates the input control for the spinner and adds it to
         * the widget&#x27;s content box, if not already in the markup.
         *&#x2F;
        _renderInput : function() {
            var contentBox = this.get(&quot;contentBox&quot;),
                input = contentBox.one(&quot;.&quot; + Spinner.INPUT_CLASS),
                strings = this.get(&quot;strings&quot;);

            if (!input) {
                input = Node.create(Spinner.INPUT_TEMPLATE);
                contentBox.appendChild(input);
            }

            input.set(&quot;title&quot;, strings.tooltip);
            this.inputNode = input;
        },

        &#x2F;*
         * Creates the button controls for the spinner and add them to
         * the widget&#x27;s content box, if not already in the markup.
         *&#x2F;
        _renderButtons : function() {
            var contentBox = this.get(&quot;contentBox&quot;),
                strings = this.get(&quot;strings&quot;);

            var inc = this._createButton(strings.increment, this.getClassName(&quot;increment&quot;));
            var dec = this._createButton(strings.decrement, this.getClassName(&quot;decrement&quot;));

            this.incrementNode = contentBox.appendChild(inc);
            this.decrementNode = contentBox.appendChild(dec);
        },

        &#x2F;*
         * Utility method, to create a spinner button
         *&#x2F;
        _createButton : function(text, className) {

            var btn = Y.Node.create(Spinner.BTN_TEMPLATE);
            btn.set(&quot;innerHTML&quot;, text);
            btn.set(&quot;title&quot;, text);
            btn.addClass(className);

            return btn;
        },

        &#x2F;*
         * Bounding box mouse down handler. Will determine if the mouse down
         * is on one of the spinner buttons, and increment&#x2F;decrement the value
         * accordingly.
         * 
         * The method also sets up a timer, to support the user holding the mouse
         * down on the spinner buttons. The timer is cleared when a mouse up event
         * is detected.
         *&#x2F;
        _onMouseDown : function(e) {
            var node = e.target,
                dir,
                handled = false,
                currVal = this.get(&quot;value&quot;),
                minorStep = this.get(&quot;minorStep&quot;);

            if (node.hasClass(this.getClassName(&quot;increment&quot;))) {
                this.set(&quot;value&quot;, currVal + minorStep);
                dir = 1;
                handled = true;
            } else if (node.hasClass(this.getClassName(&quot;decrement&quot;))) {
                this.set(&quot;value&quot;, currVal - minorStep);
                dir = -1;
                handled = true;
            }

            if (handled) {
                this._setMouseDownTimers(dir, minorStep);
            }
        },

        &#x2F;*
         * Override the default content box value, since we don&#x27;t want the srcNode
         * to be the content box for spinner.
         *&#x2F;
        _defaultCB : function() {
            return null;
        },

        &#x2F;*
         * Document mouse up handler. Clears the timers supporting
         * the &quot;mouse held down&quot; behavior.
         *&#x2F;
        _onDocMouseUp : function(e) {
            this._clearMouseDownTimers();
        },

        &#x2F;*
         * Bounding box Arrow up&#x2F;down, Page up&#x2F;down key listener.
         *
         * Increments&#x2F;Decrement the spinner value, based on the key pressed.
         *&#x2F;
        _onDirectionKey : function(e) {

            e.preventDefault();

            var currVal = this.get(&quot;value&quot;),
                newVal = currVal,
                minorStep = this.get(&quot;minorStep&quot;),
                majorStep = this.get(&quot;majorStep&quot;);

            switch (e.charCode) {
                case 38:
                    newVal += minorStep;
                    break;
                case 40:
                    newVal -= minorStep;
                    break;
                case 33:
                    newVal += majorStep;
                    newVal = Math.min(newVal, this.get(&quot;max&quot;));
                    break;
                case 34:
                    newVal -= majorStep;
                    newVal = Math.max(newVal, this.get(&quot;min&quot;));
                    break;
            }

            if (newVal !== currVal) {
                this.set(&quot;value&quot;, newVal);
            }
        },

        &#x2F;*
         * Simple change handler, to make sure user does not input an invalid value
         *&#x2F;
        _onInputChange : function(e) {
            if (!this._validateValue(this.inputNode.get(&quot;value&quot;))) {
                this.syncUI();
            }
        },

        &#x2F;*
         * Initiates mouse down timers, to increment slider, while mouse button
         * is held down
         *&#x2F;
        _setMouseDownTimers : function(dir, step) {
            this._mouseDownTimer = Y.later(500, this, function() {
                this._mousePressTimer = Y.later(100, this, function() {
                    this.set(&quot;value&quot;, this.get(&quot;value&quot;) + (dir * step));
                }, null, true)
            });
        },

        &#x2F;*
         * Clears timers used to support the &quot;mouse held down&quot; behavior
         *&#x2F;
        _clearMouseDownTimers : function() {
            if (this._mouseDownTimer) {
                this._mouseDownTimer.cancel();
                this._mouseDownTimer = null;
            }
            if (this._mousePressTimer) {
                this._mousePressTimer.cancel();
                this._mousePressTimer = null;
            }
        },

        &#x2F;*
         * value attribute change listener. Updates the 
         * value in the rendered input box, whenever the 
         * attribute value changes.
         *&#x2F;
        _afterValueChange : function(e) {
            this._uiSetValue(e.newVal);
        },

        &#x2F;*
         * Updates the value of the input box to reflect 
         * the value passed in
         *&#x2F;
        _uiSetValue : function(val) {
            this.inputNode.set(&quot;value&quot;, val);
        },

        &#x2F;*
         * value attribute default validator. Verifies that
         * the value being set lies between the min&#x2F;max value
         *&#x2F;
        _validateValue: function(val) {
            var min = this.get(&quot;min&quot;),
                max = this.get(&quot;max&quot;);

            return (Lang.isNumber(val) &amp;&amp; val &gt;= min &amp;&amp; val &lt;= max);
        }
    });

    &#x2F;&#x2F; Create a new Spinner instance, drawing it&#x27;s 
    &#x2F;&#x2F; starting value from an input field already on the 
    &#x2F;&#x2F; page (the #numberField text box)
    var spinner = new Spinner({
        srcNode: &quot;#numberField&quot;,
        max:100,
        min:0
    });
    spinner.render();
    spinner.focus();
});
&lt;&#x2F;script&gt;</pre>

</div>
            </div>
        </div>

        <div class="yui3-u-1-4">
            <div class="sidebar">
                

                
                    <div class="sidebox">
                        <div class="hd">
                            <h2 class="no-toc">Examples</h2>
                        </div>

                        <div class="bd">
                            <ul class="examples">
                                
                                    
                                        <li data-description="Shows how to extend the base widget class, to create your own Widgets.">
                                            <a href="widget-extend.html">Extending the Base Widget Class</a>
                                        </li>
                                    
                                
                                    
                                        <li data-description="Shows how to use Base.create and mix/match extensions to create custom Widget classes.">
                                            <a href="widget-build.html">Creating Custom Widget Classes With Extensions</a>
                                        </li>
                                    
                                
                                    
                                        <li data-description="Shows how to create an IO plugin for Widget.">
                                            <a href="widget-plugin.html">Creating a Widget Plugin</a>
                                        </li>
                                    
                                
                                    
                                        <li data-description="Shows how to extend the Widget class, and add WidgetPosition and WidgetStack to create a Tooltip widget class.">
                                            <a href="widget-tooltip.html">Creating a Simple Tooltip Widget With Extensions</a>
                                        </li>
                                    
                                
                                    
                                        <li data-description="Shows how to extend the Widget class, and add WidgetParent and WidgetChild to create a simple ListBox widget.">
                                            <a href="widget-parentchild-listbox.html">Creating a Hierarchical ListBox Widget</a>
                                        </li>
                                    
                                
                            </ul>
                        </div>
                    </div>
                

                
            </div>
        </div>
    </div>
</div>

<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>

</body>
</html>
